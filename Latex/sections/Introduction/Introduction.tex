\chapter{Introduction}
Field Programmable Gate Arrays (FPGAs) play a significant role in the semiconductor industry. Because companies can configure the logic of these devices after mass hardware production, they can effectively use them for prototyping and emulation of Application Specific Integrated Circuits (ASICs). These are chips that are custom made for specific purposes and cannot be reconfigured. FPGAs can also be used to reconfigure program logic effectively, even while the hardware is in use. Moreover, the high computing performance for parallel calculations yielded by a small chip makes an FPGA suitable for sensor systems\cite{Garcia20146247}, cryptography\cite{Yalla2009225, Nawari2015, Ikram2020172}, digital signal processing\cite{4566369}, protocol implementations\cite{Saha2014} and other types of high-performance computing\cite{Kanazawa2010}.

We should adequately educate the engineers that implement FPGA programs to exploit their potential in this variety of problem areas. Usually, this is done by having students implement programs in a Hardware Description Language (HDL) such as VHDL or Verilog, compile it using FPGA vendor software to bit-level code that is written to FPGA hardware and execute it. This type of compilation takes a significant amount of time as the place \& route process required for compilation are both NP-complete problems\cite{1585279}. Another option is to simulate FPGA programs instead. Simulation circumvents the place \& route process. However, simulation software run on a CPU has to simulate each component sequentially for each CPU core, resulting in enormous performance loss. 

Another technique is modelling the semantics of virtual FPGA components in an HDL module. The engineer can then simulate the execution of a virtual FPGA program by providing both the input \textit{and} configuration of these components as (stored) inputs to the hardware. An example of this is illustrated in Section \ref{sec:simulation} and Figure \ref{fig:simulation}. The trade-off here is that the hardware uses many resources for the simulation of each component. Because of this increased resource consumption, the performance of FPGA programs decreases as well.


Techniques that require students to implement FPGA programs in HDLs furthermore abstract away the process of place \& route, a process that significantly affects the performance of the hardware implementation of the program. Students should be aware of this process and its underlying operations to build a bottom-up understanding of the entire FPGA engineering pipeline.

We propose an education environment where students implement program logic and place \& route manually in a simple, virtual FPGA. Performing the NP-complete place \& route manually allows the rest of the compilation process to take linear time. This compilation process specifically compiles an FPGA-configuration meant for a virtual FPGA layout to a configuration compatible with a concrete one.

This way, students can circumvent the time-consuming compilation from HDLs to FPGAs, resulting in faster iterations and improved learning experiences. Furthermore, students can use this environment to learn the inherent difficulty of place \& route before they use tools that encapsulate this process in a `black box'. They will have to do this when they implement more complex structures in the virtual environment. We can achieve this emulation by calculating a mapping from the configuration of a virtual FPGA to the configuration of a real-life FPGA board (concrete FPGA). While the format of an FPGA configuration is	 usually kept secret by hardware vendors\cite{Hauck:2007:RCT:1564780, 8653869, 6339165}, some FPGA boards have been reverse engineered to reveal the underlying format\cite{Yu2018}. Once this technique has been implemented and tested on those FPGAs, It can be put in practice in lab sessions of colleges and universities. Moreover, vendors can implement it for undisclosed FPGA designs and configuration formats as well for educational purposes as well.

This research applies an algorithm for the graph problem `node disjoint subgraph homeomorphism': an embedding of some source graph in a target graph, where addition of intermediate vertices is permitted. Applying this algorithm to graph models of FPGA provides such a mapping. We furthermore improve this algorithm using various methods from the domain of subgraph isomorphism (a similar graph problem), evaluate the different settings/improvements of this algorithm and how practical this algorithm is for educational use cases. 

Another use case of such mappings is synthesis of the same configuration to many hardware FPGA devices. Using our technique, synthesis of some FPGA program only has to take place once (to a virtual FPGA) before suitable configurations can be retrieved for many hardware architectures. Other applications may also benefit from this research when viewing partial FPGA emulation as a form of pre-compilation: performing FPGA compilation as much as possible without the knowledge of some aspects of the configuration. If this research is extended to include other forms of partial compilation, it may be used to improve the speed of general iterations of FPGA development as well.