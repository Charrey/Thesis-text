\chapter{Introduction}
Field Programmable Gate Arrays (FPGAs) play a significant role in the semiconductor industry. Because companies can configure the logic of these devices after mass hardware production, they can effectively use them for prototyping and emulation of Application Specific Integrated Circuits (ASICs). These are chips that are custom made for specific purposes and cannot be reconfigured. FPGAs can also be used to reconfigure program logic effectively, even while the hardware is in use. Moreover, the high computing performance for parallel calculations yielded by a small chip makes an FPGA suitable for sensor systems \cite{Garcia20146247}, cryptography\cite{Yalla2009225, Nawari2015, Ikram2020172}, digital signal processing\cite{4566369}, protocol implementations\cite{Saha2014} and other types of high-performance computing \cite{Kanazawa2010}.

We should adequately educate the engineers that implement FPGA programs to exploit their potential in this variety of problem areas. Usually, this is done by having students implement programs in a Hardware Description Language (HDL) such as VHDL or Verilog, compile it using FPGA vendor software to bit-level code that is written to FPGA hardware and execute it. This type of compilation takes a significant amount of time as the place \& route process required for compilation are both NP-complete problems \cite{1585279}. Another option is to simulate FPGA programs instead, which is the industry standard used for testing ASICs (non-programmable FPGAs). Simulation circumvents the place \& route process. However, simulation software run on a CPU has to simulate each component sequentially for each CPU core, resulting in enormous performance loss and thus a negative learning experience.

Another technique that could be used to execute an FPGA configuration is modelling the semantics of virtual FPGA components in an HDL module. The engineer can then simulate the execution of a virtual FPGA program by providing both the input \textit{and} configuration of these components as (stored) inputs to the hardware. An example of this is illustrated in Section \ref{sec:simulation} and Figure \ref{fig:simulation}. The trade-off here is that the hardware uses many resources for the simulation of each component. Because of this increased resource consumption, the performance of FPGA programs decreases as well. This technique is generally not used in the industry because of this reduced performance.

Techniques that require students to implement FPGA programs in HDLs furthermore abstract away the process of place \& route, a process that significantly affects the performance of the hardware implementation of the program. Since students should be educated to use this process optimally or even improve it, they should be aware of it and its underlying operations to build a bottom-up understanding of the entire FPGA engineering pipeline.

We propose an education environment where students implement program logic and place \& route manually in a simple, virtual FPGA. This way, the course designer has full control over the learning environment without being constrained to physical hardware. Performing the NP-complete place \& route manually allows the rest of the compilation process to take linear time, providing a configuration for the virtual FPGA. We aim to devise a method to compile this configuration for a virtual FPGA to a configuration compatible with a concrete one in linear time.

This way, students can circumvent the time-consuming compilation from HDLs to FPGAs, resulting in faster iterations and improved learning experiences. Furthermore, students can use this environment to learn the inherent difficulty of place \& route before they use tools that encapsulate this process in a `black box'. They will have to do this when they implement more complex structures in the virtual environment.

We can achieve this emulation by calculating a \textit{mapping} from the configuration of a virtual FPGA to the configuration of a real-life FPGA board (concrete FPGA). This mapping retains the semantics of the configuration but makes it suitable for execution on real hardware. While the format of an FPGA configuration is usually kept secret by hardware vendors \cite{Hauck:2007:RCT:1564780, 8653869, 6339165}, some FPGA boards have been reverse engineered to reveal the underlying format \cite{Yu2018, trellis}. Once this technique has been implemented and tested on those FPGAs, It can be put in practice in lab sessions of colleges and universities. Moreover, vendors can implement it for undisclosed FPGA designs and configuration formats as well for educational purposes as well.

%This research applies a space-efficient variant of Xiao's algorithm \cite{XIAONODEDISJOINT} for the graph problem `subgraph homeomorphism': an embedding of some source graph in a target graph, where addition of intermediate vertices is permitted. Applying this algorithm to graph models of FPGA provides such a mapping. We furthermore improve this algorithm using various methods from the domain of subgraph isomorphism (a similar graph problem), evaluate the different settings/improvements of this algorithm and how practical this algorithm is for educational use cases. 

Another use case of such mappings is synthesis of the same configuration to many hardware FPGA devices. Using our technique, synthesis of some FPGA program only has to take place once (to a virtual FPGA) before suitable configurations can be retrieved for many hardware architectures. Other applications may also benefit from this research when viewing partial FPGA emulation as a form of pre-compilation: performing FPGA compilation as much as possible without the knowledge of some aspects of the configuration. If this research is extended to include other forms of partial compilation, it may be used to improve the speed of general iterations of FPGA development as well.

The goals of this research are specified in Chapter \ref{sec:Objectives} (Objectives). This is a more specific description of the problem we outlined in this introduction requiring little background information. In Chapter \ref{sec:background} (Background) we will provide background on FPGAs and the graph problem `subgraph homeomorphism': a graph problem we will use to reach our objectives. In Chapter \ref{chapter:models} (Models) we specify how we model FPGAs as graphs to make them applicable for subgraph homeomorphism. In Chapter \ref{chapter:algorithm} (Algorithm) we describe the algorithm we use to solve the subgraph homeomorphism with these graphs. We prune the search space with methods described in Chapter \ref{chapter:pruning} (Pruning). We perform experiments with models and the algorithm with different settings in Chapter \ref{chapter:experiments} (Experiments), followed by a discussion (Chapter \ref{chapter:discussion}) interpreting the results and a conclusion in Chapter \ref{chapter:conclusion}.