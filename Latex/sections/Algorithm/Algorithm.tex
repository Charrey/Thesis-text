\chapter{Algorithm}

\tikzstyle{decision} = [diamond, align=center, draw=black]

\tikzstyle{block} = [rectangle, minimum width=2.5cm, minimum height=1cm, align=left, draw=black]


\section{Baseline: ndSHD2}
In our research we will extend existing work on node disjoint subgraph isomorphism. In the literature we found two existing well-defined algorithms: Xiao's algorithm `ndSHD2' \cite{XIAONODEDISJOINT} and Lingas algorithm \cite{LINGAS2009464}. We choose to adapt Xiao's algorithm ndSHD2 as baseline over Lingas because it is simpler, includes a method for calculating a vertex-on-vertex mapping and has many similarities with subgraph isomorphism algorithms. In comparison, Lingas' algorithm suggests attempting their edge-path mapping strategy on every possible vertex-on-vertex mapping. We will adapt Xiao's algorithm to compute paths on-the-fly instead of beforehand to avoid the exponential space requirement.

To understand ndSHD2 better, let us first examine what the output is supposed to be. The algorithm should, given two graphs, not just indicate whether the latter graph has a subgraph homeomorphism of the former, but also indicate what subgraph homeomorphism that is. More formally, we need to solve the \textit{certification} problem rather than the \textit{decision} problem. This certification indicates to which target graph vertex each source graph vertex is mapped and to which target graph path each source graph edge is mapped such that the entire mapped source graph is a subgraph of the target graph. This is what we will from now on refer to as the \textbf{mapping}. If, during the execution, the mapping is not yet complete, i.e. it does not have a target for some source graph vertex or edge, we refer to it as the \textbf{partial mapping}.

\begin{algorithm}
\SetAlgoLined
\textbf{Inputs: } the current vertex-vertex partial mapping $\mathit{vmap}$, the current edge-path $\mathit{emap}$ partial mapping\\
\textbf{Outputs: } \textit{found}, indicating whether a valid subgraph homeomorphism has been found.\\
\If{$s$ is dead state} {
	\Return false\;
} \ElseIf {$s$ is complete} {
	\Return true\;
}

$\mathit{found} \longleftarrow \mathit{false}$

 \While{$!\mathit{found} \land \exists$ valid node/edge-path mapping pair}{
  $m \longleftarrow \mathit{GetNextNodePair}()$\tcp*[h]{$m \longleftarrow \mathit{GetNextEdgePathPair}()$}\;
  
  \If{$\mathit{wouldPrune}(\mathit{vmap}, \mathit{emap}, m)$} {
  	\textbf{continue}\;
  }  
  
  $\mathit{vmap}' \longleftarrow \mathit{Backup}(\mathit{vmap})$\tcp*[h]{ 
  $\mathit{emap}' \longleftarrow \mathit{Backup}(\mathit{emap})$}\; 
  $\mathit{vmap} \longleftarrow \mathit{vmap} \cup \{m\}$\tcp*[h]{$\mathit{emap} \longleftarrow \mathit{emap} \cup \{m\}$}\;  
  
  $\mathit{found} \longleftarrow \mathit{ndSHD2}(s, \mathit{vmap}, \mathit{emap})$\;
  \If{found} {
  	\Return true\;
  }
  $\mathit{vmap} \longleftarrow \mathit{Recover}(\mathit{vmap})$\tcp*[h]{ 
  $\mathit{emap}' \longleftarrow \mathit{Recover}(\mathit{emap})$}\;
 }
 \Return false\;
 \caption{ndSHD2}
 \label{algorithm:ndSHD2}
\end{algorithm}


\begin{algorithm}
\SetAlgoLined
\textbf{Inputs: } the current vertex-vertex partial mapping $\mathit{vmap}$, the current edge-path $\mathit{emap}$ partial mapping\\
\textbf{Outputs: } \textit{found}, indicating whether a valid subgraph homeomorphism has been found.\\

\If{contraction} {
	$G_S, \mathit{chains} \longleftarrow \mathit{contract}(G_S)$
}

 \Return ndSHD3($\mathit{vmap}$, $\mathit{emap}$)\;
 \caption{ndSHD3-contract}
 \label{algorithm:ndSHD3}
\end{algorithm}

\begin{algorithm}
\SetAlgoLined
\textbf{Inputs: } the current vertex-vertex partial mapping $\mathit{vmap}$, the current edge-path $\mathit{emap}$ partial mapping\\
\textbf{Outputs: } \textit{found}, indicating whether a valid subgraph homeomorphism has been found.\\

\If {$s$ is complete} {
	\Return true\;
}

$\mathit{found} \longleftarrow \mathit{false}$

 \While{$!\mathit{found} \land \exists$ valid node/edge-path mapping pair}{

\If{$\mathit{hasUnmatchedEdge}()$} {
	$(e_S, p_T) \longleftarrow \mathit{GetNextEdgePathPair}()$\;
	\If{$\mathit{wouldPrune}(\mathit{vmap}, \mathit{emap} \cup \{(e_S, p_T)\})$} {
  		\textbf{continue}\;
  	}
  	$\mathit{emap} \longleftarrow \mathit{emap} \cup \{(e_S, p_T)\}$\;
  	$\mathit{found} \longleftarrow \mathit{ndSHD3}(\mathit{vmap}, \mathit{emap})$\;
  \If{found} {
  	\Return true\;
  }
  $\mathit{emap} \longleftarrow \mathit{emap} \cap \{(e_S, p_T)\}$\;
} \Else {
	$(v_S, v_T) \longleftarrow \mathit{GetNextNodePair}()$\;
	\If{$\mathit{wouldPrune}(\mathit{vmap} \cup \{(v_S, v_T)\}, \mathit{emap})$} {
  		\textbf{continue}\;
  	}
  	$\mathit{vmap} \longleftarrow \mathit{vmap} \cup \{(v_S, v_T)\}$\;
  	$\mathit{found} \longleftarrow \mathit{ndSHD3}(\mathit{vmap}, \mathit{emap})$\;
  \If{found} {
  	\Return true\;
  }
  	$\mathit{vmap} \longleftarrow \mathit{vmap} \cap \{(v_S, v_T)\}$\;
}

 }
 \Return false\;
 \caption{ndSHD3}
 \label{algorithm:ndSHD3}
\end{algorithm}




\begin{algorithm}
\SetAlgoLined
\textbf{Inputs: } the current vertex-vertex partial mapping $\mathit{vmap}$, the current edge-path $\mathit{emap}$ partial mapping\\
\textbf{Outputs: } whether pruning should be applied.\\
$\mathit{domains} \longleftarrow \mathit{filterDomains}(\mathit{vmap}, \mathit{emap})$\;
\If {ZeroDomain} {
	\If {$\emptyset \in \mathit{values}(\mathit{domains})$} {
		\Return false\;
	}
} \ElseIf {AllDifferent} {
	\If {$\lnot \mathit{satisfiesAllDifferent}(\mathit{domains})$} {
		\Return false\;
	}
}
\Return true\;
 \caption{wouldPrune}
 \label{algorithm:ndSHD3}
\end{algorithm}


ndSHD2 Is shown in Algorithm \ref{algorithm:ndSHD2}. It is a form of depth first search in a partial mapping search space that attempts- and backtracks vertex-on-vertex mappings and edge-on-path mappings.

In our literature study, we found that the core of many subgraph isomorphism algorithms\footnote{Ullman, VF, VF2, VF2+, VF2++, UI, Fast-ON, L2G, Cheng, QuickSI, GraphQL, ILF, TurboISO, Glassgow, CLF-Match, RI, RI-DS, McGregor, LAD, PathLAD} is a form of similar DFS state space exploration where the states consist of partial vertex-to-vertex mappings. In subgraph isomorphisms, the edge-to-edge mapping is elementary by performing the vertex mapping on the edge source and target to obtain the target edge. With the subgraph homeomorphism algorithm such as Xiao's, an additional mapping from $E_S$ to the path set of $G_T$ is needed.

The algorithm starts with an empty partial mapping, and starts mapping source graph vertices to target graph vertices. Whenever both vertices of a source graph edge have been matched, the algorithm finds an arbitrary path between the mapped edge source and target in the target graph that is internally disjoint from target graph vertices already used in the partial mapping. The algorithm prioritizes extending the matching with an edge-path pair over extending it with a vertex-vertex pair. Whenever no such path or vertex exists, the algorithm undoes (backtracks) the last matching step taken and tries a different alternative. Whenever a partial match is extended with a vertex-vertex pair or with an edge-path pair the search space is refined using a pruning strategy implemented by the $Refine(M,R)$ call. This method filters out future path candidates from a path storage and from a vertex storage according to zero-domain N-reachability pruning (see Chapter \ref{chapter:pruning} for definitions). This removes path candidates and vertex candidates that can provably not be part of any valid subgraph homeomorphism mapping.

The algorithm as specified in Xiao's paper leaves out some specific ordering details- we will assume that they used random ordering. We specify which vertex order we use in Sections \ref{sec:sourceOrder}, \ref{sec:targetOrder}. We will explain what order of paths we use in Section \ref{sec:pathIterationShort}.

\section{How to choose vertex-vertex pairs}
There are different ways to choose which vertex-vertex pair to add to the partial mapping first, and which only to try after other attempts have failed. These methods can be divided into three categories:

\begin{enumerate}
\item Choose a source graph vertex first using some heuristic, then attempt all target graph vertex candidates using another heuristic.
\item Choose a target graph vertex first using some heuristic, then attempt all source graph vertex candidates using another heuristic.
\item Choose a source vertex-target vertex with high heuristic first, then attempt all other pairs.
\end{enumerate}

While the strategy used does not affect the vertex-on-vertex mapping state space, it can affect the average-case performance. Strategy 3, for example, uses combined heurstics that may be more powerful. The disadvantage of it requires $O(|V_s|*|V_t|)$ heuristic computations before the first pair is obtained. If these computations are done beforehand the heuristic cannot take the current partial mapping into account and is likely to be weak. Is this computation is done at each step in the search process, it introduces considerable delay.

Strategies 1 and 2, on the other hand, require only $O(|V_s|+|V_t|)$ heuristic calculations to be made before obtaining a candidate pair. We choose a source graph vertex heuristic that is precomputed and provide two heuristics for target graph vertices, one of which is precomputed and one of which is calculated run-time.

\section{Source graph vertex order}
\label{sec:sourceOrder}
The source graph vertex order is the order in which source graph vertices are added to the partial mapping. For example, if $s_1 \prec_M s_2$ in this ordering, then a pair with $s_2$ and some target graph vertex will only be added to the partial mapping if a pair with $s_1$ is already in it within the context of a partial matching $M$. If this ordering depends on $M$, it has to be calculated at run-time. If it does not, it only has to be calculated once.

Xiao does not specify a source graph vertex order. Instead, we will use a high-performance ordering technique from the subgraph \textit{isomorphism} domain. From performance comparisons we extract that the best performing algorithm that adheres to partial mapping search for subgraph isomorphism is RI-DS. In our literature study, we found no evidence a faster algorithm exists. This ordering does not depend on $M$, and thus we will precompute the entire ordering.

To describe the ordering process of RI-DS, let us provide a few definitions:

\begin{defn}[predecessors and successors]
Given two graphs $G=(V, E, L)$ and some vertex $v \in V$, their predecessors and successors are defined as follows:

$\mathit{succ}(v) := {v' \in V . (v, v') \in E}$

$\mathit{pred}(v) := {v' \in V . (v', v) \in E}$
 
\end{defn}

\begin{defn}[neighbour set]
If some $v\in V$, then $\mathit{neighbours}(v):= \mathit{succ}(v) \cup \mathit{pred}(v)$.
\end{defn}

%\begin{defn}[E for sets of vertices]
%If some $S\subseteq V$, then $E(S):=\bigcup\limits_{v \in S} E(v)$.
%\end{defn}


The algorithm RI-DS obtains a variable ordering using a greedy algorithm called ``GreatestConstrainedFirst". This algorithm starts with an ordering $\mu$ containing only the source graph vertex with the highest degree, i.e. $v\in V_1$ where $|\mathit{neighbours}(v)|$ is highest. Then, each source graph vertex not yet in the order is assigned three scores $N_1$, $N_2$ and $N_3$. $N_1(s_x)$ is the number of neighbours of $s_x$ that are already in the order (i.e. $|\{s_y | s_y \in \mathit{neighbours}(s_x) \land s_y \in \mu\}$|). $N_2(s_x)$ is the number of neighbours of $s_x$ that are not in the order themselves, but do have a neighbour in the order (i.e. $|\{s_y | s_y \in \mathit{neighbours}(s_x) \land s_y \not \in \mu \land |\mathit{neighbours}(s_y) \cap \mu| > 0\}$|). $N_3(s_x)$ is the number of all remaining neighbours of $s_x$ (i.e. $|\{s_y | s_y \in \mathit{neighbours}(s_x) \land s_y \not \in \mu \land |\mathit{neighbours}(s_y) \cap \mu| = 0\}$|). It selects each vertex $v$ of which $N_1(v)$ is greatest. Ties are broken with the greatest $N_2$-value, and any remaining ties are broken with the greatest $N_3$-value. Any remaining ties are broken randomly. The selected vertex is added to the back of the order, and the process repeats. This continues until every vertex has been added to the order.

The result of this ordering is that consequent vertices have many edges with vertices earlier in the ordering. Xiao established that matching edges as soon as possible (rather than matching vertices first) results in a faster algorithm. Using an order that allows early placement of edges such as GreatestConstrainedFirst should accoring to Xiao result in fast execution.
\section{Target graph vertex order}
\label{sec:targetOrder}

The target graph vertex order is the order in which target graph vertices are added to the partial mapping. For example, if $t_1 \prec t_2$ in this ordering, then a pair with $t_2$ and some source graph vertex $s_x$ will only be added to the partial mapping if the pair $(s_x, t_1)$ was already proved unfeasible. Xiao does not describe a specific target graph vertex order.

We found one subgraph isomorphism algorithm that describes a specific target graph vertex order, being Glasgow \cite{McCreesh2015}. In this algorithm, target graph vertices with higher degree are prioritized. Since this does not depend on the chosen source graph vertex or on the current partial matching, this order can be precomputed, introducing only linear complexity. Formally, when some source graph vertex $s$ needs to be matched, $x$ are chosen using the following metric, choosing vertices with lower metric values first:

$$\mathit{metric}_\mathit{degree}(s, t)=-|\mathit{neighbours}(t)|$$

Another option is to take the current partial mapping into account. Using a degree-based or random target graph vertex order will result in consectively chosen target graph vertices being spread roughly evenly throughout graph. Since we optimise our algorithm for large target graphs, chosen vertices at arbitrary locations will likely result in long paths necessary to reach them, and thus in unneccessary resource usage. However, we can use information from the current partial mapping to obtain better candidates: since we know the chosen source graph vertex and thus which edges will be mapped after this vertex-vertex pair, we can choose our target vertex such that the paths associated with these edges are as short as possible.

Whenever we need to match some source graph vertex $s_x$, This distance-based method will choose target vertices first that have the lowest distance to the source graph vertex' neighbours that are already in the partial matching. The result is that fewer number of vertices need to be used as intermediate vertex in the paths associated with the edges to those neighbours. The disadvantage of this method is that it requires runtime usage of a computionally expensive shortest path algorithm to choose a target graph vertex candidate. The shortest path algorithm can be cached, which reduces the number of computations needed after backtracking but introduces quadratic\footnote{$O(|V_s|*|V_t|)$} space usage (we implement this with- and without caching). Formally, when some source graph vertex $s_x$ needs to be matched, $t_x$ are chosen using the following metric, choosing vertices with lower metric values first:


$$\mathit{metric}_\mathit{distance}(s, t)=\sum_{s' \in E(s)} \begin{cases}
|\mathit{shortestPathUndirected}(M(s'), t)| & s' \prec_\mu s\\
0 & s \prec_\mu s'
\end{cases}$$

Here, $M$ is the current partial mapping and $\mu$ is the source graph vertex order. We implemented both methods to use in our algorithm.

\section{Path iteration}
\label{sec:pathIterationShort}
In subgraph isomorphism, edge-on-edge mappings are trivial from vertex-on-vertex mappings. However, in subgraph homeomorphism a source graph edge may be mapped on many target graph path candidates (all starting- and ending at the same two vertices). Therefore, we cannot extract the order in which to try out paths from subgraph isomorphism. Instead, we implemented different methods to iterate over paths to try:

\begin{itemize}
\item \textbf{K-path -} Try all loopless paths from shortest to longest, avoiding unusable vertices in the existing partial mapping. We use Yen's algorithm \cite{YensAlgorithm} for this. Faster and more recent algorithms exist \cite{Hershberger, Brander1996} but lack public implementations.

\item \textbf{DFS -} Search for paths using depth first search from the start vertex, choosing arbitrary directions at each vertex and avoiding unusable vertices in the existing partial mapping.

\item \textbf{Greedy DFS (graph distance) -} Search for paths using greedy depth first search, choosing the direction closest to the goal vertex first (avoiding unusable vertices in the existing partial mapping). We implement both a variant that precomputes all shortest paths and a variant that calculates at run-time which direction to choose (without caching).

\item \textbf{Greedy DFS (informed graph distance) -} Search for paths using greedy depth first search, choosing the direction closest to the goal vertex along a path that avoids unusuble vertices first (avoiding unusable vertices in the existing partial mapping). We compute run-time which direction to choose.

\item \textbf{Control point -} Select increasingly many `control points' (from $0$ to $|V|$) randomly in the target graph that must be in the path in a specific order, then connecting them by a shortest path algorithm that avoids unusable vertices in the existing partial mapping. We implemented this with a recursive algorithm in which a replacement of some control point is only attempted if all control points \textit{earlier} in the control point order have been attempted.\footnote{To avoid duplicate paths, any path that can be generated with fewer control points is skipped. Furthermore, any control point configuration where shifting some control point towards the goal vertex along the path results in the same path is skipped.}
\end{itemize}

These methods provide for each two vertices in a graph each path connecting them exactly once. The space requirements for each method are shown in Table \ref{tab:iterator-spacerequirements}, and examples of paths returned by them are shown in Appendix 2.

\begin{table}[]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Path iterator} & \textbf{Space complexity} \\ \hline
K-Path                 & $O(|V|!)$                 \\ \hline
DFS                    & $O(|V|)$                  \\ \hline
Greedy DFS             & $O(|V|^2)$                \\ \hline
Control point          & $O(|V|)$                  \\ \hline
\end{tabular}
\caption{Worst-case space complexity of each path iteration strategy. The computational requirements of each method change in different ways for subsequent calls.}
\label{tab:iterator-spacerequirements}
\end{table}


\section{Optimisations}
In addition to implementing ordering parameters of the ndSHD2 algorithm, we implement some optimisations (some of which from the subgraph isomorphism domain) and individually evaluate them. 

\subsection{Refusing long paths}
Since path iterators may provide any valid path to map an edge to during the matching process, they may also provide paths that take up unnecessarily many resources. Specifically, they take up so many resources that with a subset of the vertices and edges of that path, a shorter path can be formed. Formally, some path $p$ is ``unnecessarily long" iff:


$\exists p' \in P . first(p') = first(p) \land last(p') = last(p) \land intermediate(p') \subset intermediate(p)$

With this optimisation enabled, such paths are skipped by path iterators. Examples of this effect are shown in Figures \ref{fig:pathexamples-dfs} and \ref{fig:pathexamples-greedydfs}.

\subsection{Runtime Pruning}
Some subgraph isomorphism algorithms \cite{Cordella2004, McCreesh2015} prune the search space during the search using some detection method of dead search paths. In Chapter \ref{chapter:pruning} we will elaborate on the different techniques we implement for subgraph homeomorphism.

\subsection{Contraction}
The source graph of a homeomorphism case will often contain vertices that have exactly one incoming edge and one outgoing edge. In FPGAs, for example, these could be transistors or ports of components. These vertices do topologically nothing but serve as an edge; therefore they may also be thought of as an edge, where the edge source is the vertex' predecessor and the edge target is the vertex' successor. When we use the word contraction, we mean surpressing all such vertices and replacing them with a single edge, as illustrated in Figure \ref{fig:contraction-basic}. This process transforms the source graph $S$ into the smallest graph $S_{cont}$ that is topologically equivalent to $S$. This may be a multigraph or a graph that contains self-loops. If a subgraph homeomorphism exists from $S$ to some target graph $T$, then there also exists a subgraph homeomorphism from $S_{cont}$ to $T$ (a proof is given in Appendix \ref{proof:contractionHomeo}). The optimisation `contraction' searches for a homeomorphism between $S_{cont}$ and the $T$ instead of finding one between $S$ and $T$. Because this involves a smaller source graph, it also involves a smaller search space.

The process of finding a homeomorphism from $S_{cont}$ to $T$ is slightly different from what normal. This is because while every homeomorphism from $S$ to $T$ can be deduced to a homeomorphism between $S_{cont}$ and $T$ (by contraction of vertices and concatenation of paths), not every homeomorphism from $S_{cont}$ and $T$ allow a homeomorphism from $S$ to $T$ to be inferred. An example is the case where $S_{cont}$ is isomorphic to $T$ and $S$ subdivides a single edge of $S_{cont}$: there exists a subgraph homeomorphism from $S_{cont}$ to $T$ since they are isomorphic, but there is no subgraph homeomorphism from $S$ to $T$. Because of this, we need to adapt the subgraph homeomorphism search process such that it only finds subgraph homeomorphisms from which we \textit{can} infer a subgraph homeomorphism from $S$ to $T$.

When we apply contraction to replace a series of edges $E$ by a single edge $e$, we save the label sets for each intermediate vertex in $E$ in the order that they appear (following the direction of $e$) before starting the search algorithm. 

During edge-path matching in the partial mapping search, we may need to map an edge $(u, v)$ that contains contracted vertices. For each edge $\in E_{cont}$ with the same source- and target vertex we recall their lists of contracted label sets. Each time we find a path candidate for $(u, v)$ we check compatibility of that path with each of those lists of label sets. We then retrieve all other paths already found for edges with this source- and target and use an all-different constraint (see Section \ref{sec:alldifferent}) to verify that each edge $\in E_{cont}$ has a compatible path. Whenever the number of paths is smaller than the number of edges (i.e. paths still need to be found futher in the partial mapping search), we assume paths that are compatible with every list of label sets.

If the all-different constraint fails, it implies that from the current partial mapping we cannot find paths that emulate the contracted vertices, and we backtrack. If the all-different constraint succeeds, finding a subgraph homeomorphism is still possible and we continue.

This optimisation introduces some delay since the algorithm needs to check compatibility between label set sequences and paths and solve an all-different constraint. However, it also saves time since it reduces the source graph's size.

\subsubsection{Contraction for undirected graphs}
Although we are focued on directed graphs in our algorithm, it is interesting to note that each optimisation is also applicable to undirected graphs, including contraction. Contraction can be applied to undirected graphs by temporarily applying a uniform direction to each chain of 2-degree vertices in the source graph and then applying directed contraction, after which the edges may lose their direction again. Then, during the compatibility checking process we perform the same procedure, making sure the list of label sets is checked in the correct direction, i.e. for each temporarily directed edge $(u, v) \in E_{cont}$ and partial mapping $M$, the path $M(u, v)$ in $T$ should be checked in the direction from $M(u)$ to $M(v)$.



\begin{figure}
\begin{subfigure}{.5\textwidth}
  \centering
\includegraphics[width=0.8\linewidth]{images/contraction/whatisit1.png}
  \caption{Part of a source graph that may be contracted}
\end{subfigure}
\begin{subfigure}{.5\textwidth}
  \centering
\includegraphics[width=0.8\linewidth]{images/contraction/whatisit2.png}
  \caption{The result of contraction}
\end{subfigure}
\caption{Contraction applied to vertex $s_2$, a vertex with indegree 1 and outdegree 1. During contraction, we save that a single vertex has been contracted with an empty label set.}
\label{fig:contraction-basic}
\end{figure}


\begin{figure}
\begin{subfigure}{.5\textwidth}
  \centering
\includegraphics[scale=0.6]{images/contraction/after.png}
  \caption{A source graph before contraction}
\end{subfigure}
\begin{subfigure}{.5\textwidth}
  \centering
  % include second image
\includegraphics[scale=0.6]{images/contraction/before.png}
  \caption{The same source graph after contraction.}
\end{subfigure}
\caption{Contraction applied to a source graph with labels. With this optimisation, 3 fewer vertices and 4 fewer edges need to be mapped. During contraction, we save the label sets of the contracted vertices in the order of the contracted path.}
\label{fig:contraction}
\end{figure}


\section{Avoiding unintended current flow}
\label{sec:unintendedcurrent}
As mentioned in Chapter \ref{chapter:models}, the concrete FPGA may contain transistors that are always enabled, i.e. cannot be configured to block the flow of electrical current and function as a diode. If we would ignore this property of transistors, we may obtain a mathematically sound subgraph homeomorphism that does not include every unconfigurable transistor from the target graph in its mappings. If some unconfigurable transistor (or a sequence of them) connect two vertices in the target graph that \textbf{are} part of the mapping, then the subgraph homeomorphism does not describe a valid emulation: if the state of two components are independent in the virtual FPGA they should be independent in the concrete FPGA as well to preserve the semantics of the FPGA configuration. To avoid this issue, we propose two measures:

\subsection{Avoiding unintended current flow from/to paths}
Our first remedy is to avoid adding target graph vertices to the partial mapping that are connected to some path already present in the edge-path partial mapping through unconfigurable vertices. We do this by deleting those vertices and re-adding them whenever we backtrack the corresponding edge-path pair. More formally:

Let $\mathit{unconfigurable}\in (V_T \times V_T)$ be the relation between two vertices if they are connected through a vertex representing a unconfigurable transistor, i.e:

\vspace{10pt}

\begin{center}
\begin{tabular}{ll}
$\mathit{unconfigurable} := \{(t_1, t_2) \in (V_T \times V_T) | \exists u \in (V_T \setminus \{t_1, t_2\}) .$&$\mathtt{UNCONFIGURABLE} \in L(u) \land$\\
&$\{(t_1, u), (u, t_2)\} \subseteq E_T\}$
\end{tabular}
\end{center}

\vspace{10pt}
Let $\mathit{unconfigurable}^*$ be the symmetric closure of the transitive closure of $\mathit{unconfigurable}$. Then, whenenever we add an edge-path pair $(e, p)$ to the partial mapping, we delete each vertex $x$ for which $\exists v \in \mathit{intermediate}(p) . (x, v) \in \mathit{unconfigurable}^*$. Whenever the edge-path pair is removed from the partial mapping, each such vertex and their edges is added back to the target graph.


\subsection{Avoiding unintended current flow between mapped vertices}
Our second remedy is to avoid adding target graph vertices to the partial mapping that are connected to some target graph vertex already present in the vertex-vertex partial mapping through unconfigurable vertices. We also do this by deleting those vertices and re-adding them whenever we backtrack the corresponding vertex-vertex pair. More formally, whenever we add a vertex-vertex pair $(s, t)$ to the partial mapping, we delete each vertex $x$ for which $(x, t) \in \mathit{unconfigurable}^*$. Whenever the vertex-vertex pair is removed from the partial mapping, each such vertex and their edges is added back to the target graph.





