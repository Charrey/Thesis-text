\chapter{Objectives}
\label{sec:Objectives}
This research involves how to emulate a virtual FPGA on a concrete FPGA. To this purpose, we have established the following research question:

Given a graph specification of the structural layout of a virtual FPGA $A$ and a graph specification of the structural layout of a concrete FPGA $B$, how do you assemble a linear\footnote{i.e. a numeric constant $c$ exist such that the number of instructions required in the execution of $f$ is less than $c * (\text{the number of configurable components of the virtual FPGA})$. Note that this depends on the size of the \textit{unconfigured} virtual FPGA, not on the size of the user-provided configuration of said FPGA.} function $f$ such that for any representative model of a program $x$ for model A, $f(x)$ is a representative model of a program for model B that is semantically equivalent?
\section*{Subquestion 1}
How do the computational- and space requirements of the generation (not execution) of $f$ scale with the size of FPGAs A and B?
\section*{Subquestion 2}
How much wiring and how many components does the concrete FPGA need for emulation of a virtual FPGA of complexity $x$? Is this practical for use in education?
\section*{Expected outcomes}
We expect an algorithm and an implementation of that algorithm that, given models of both a virtual FPGA and a (larger) concrete FPGA, generates a function that translates a model of an FPGA program compatible with the virtual FPGA to a model of an FPGA program compatible with the concrete FPGA. We generalise this algorithm to other use cases with the same underlying mathematical problem (node disjoint subgraph homeomorphism). Furthermore, we include specifications on how to model FPGA models for this purpose. 